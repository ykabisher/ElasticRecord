/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/mutation-summary/src/mutation-summary.js":
/*!***************************************************************!*\
  !*** ./node_modules/mutation-summary/src/mutation-summary.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright 2011 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nvar __extends = this.__extends || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    __.prototype = b.prototype;\n    d.prototype = new __();\n};\nvar MutationObserverCtor;\nif (typeof WebKitMutationObserver !== 'undefined')\n    MutationObserverCtor = WebKitMutationObserver;\nelse\n    MutationObserverCtor = MutationObserver;\nif (MutationObserverCtor === undefined) {\n    console.error('DOM Mutation Observers are required.');\n    console.error('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');\n    throw Error('DOM Mutation Observers are required');\n}\nvar NodeMap = (function () {\n    function NodeMap() {\n        this.nodes = [];\n        this.values = [];\n    }\n    NodeMap.prototype.isIndex = function (s) {\n        return +s === s >>> 0;\n    };\n    NodeMap.prototype.nodeId = function (node) {\n        var id = node[NodeMap.ID_PROP];\n        if (!id)\n            id = node[NodeMap.ID_PROP] = NodeMap.nextId_++;\n        return id;\n    };\n    NodeMap.prototype.set = function (node, value) {\n        var id = this.nodeId(node);\n        this.nodes[id] = node;\n        this.values[id] = value;\n    };\n    NodeMap.prototype.get = function (node) {\n        var id = this.nodeId(node);\n        return this.values[id];\n    };\n    NodeMap.prototype.has = function (node) {\n        return this.nodeId(node) in this.nodes;\n    };\n    NodeMap.prototype.delete = function (node) {\n        var id = this.nodeId(node);\n        delete this.nodes[id];\n        this.values[id] = undefined;\n    };\n    NodeMap.prototype.keys = function () {\n        var nodes = [];\n        for (var id in this.nodes) {\n            if (!this.isIndex(id))\n                continue;\n            nodes.push(this.nodes[id]);\n        }\n        return nodes;\n    };\n    NodeMap.ID_PROP = '__mutation_summary_node_map_id__';\n    NodeMap.nextId_ = 1;\n    return NodeMap;\n})();\n/**\n *  var reachableMatchableProduct = [\n *  //  STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED\n *    [ STAYED_OUT,  STAYED_OUT,  STAYED_OUT,  STAYED_OUT ], // STAYED_OUT\n *    [ STAYED_OUT,  ENTERED,     ENTERED,     STAYED_OUT ], // ENTERED\n *    [ STAYED_OUT,  ENTERED,     STAYED_IN,   EXITED     ], // STAYED_IN\n *    [ STAYED_OUT,  STAYED_OUT,  EXITED,      EXITED     ]  // EXITED\n *  ];\n */\nvar Movement;\n(function (Movement) {\n    Movement[Movement[\"STAYED_OUT\"] = 0] = \"STAYED_OUT\";\n    Movement[Movement[\"ENTERED\"] = 1] = \"ENTERED\";\n    Movement[Movement[\"STAYED_IN\"] = 2] = \"STAYED_IN\";\n    Movement[Movement[\"REPARENTED\"] = 3] = \"REPARENTED\";\n    Movement[Movement[\"REORDERED\"] = 4] = \"REORDERED\";\n    Movement[Movement[\"EXITED\"] = 5] = \"EXITED\";\n})(Movement || (Movement = {}));\nfunction enteredOrExited(changeType) {\n    return changeType === Movement.ENTERED || changeType === Movement.EXITED;\n}\nvar NodeChange = (function () {\n    function NodeChange(node, childList, attributes, characterData, oldParentNode, added, attributeOldValues, characterDataOldValue) {\n        if (childList === void 0) { childList = false; }\n        if (attributes === void 0) { attributes = false; }\n        if (characterData === void 0) { characterData = false; }\n        if (oldParentNode === void 0) { oldParentNode = null; }\n        if (added === void 0) { added = false; }\n        if (attributeOldValues === void 0) { attributeOldValues = null; }\n        if (characterDataOldValue === void 0) { characterDataOldValue = null; }\n        this.node = node;\n        this.childList = childList;\n        this.attributes = attributes;\n        this.characterData = characterData;\n        this.oldParentNode = oldParentNode;\n        this.added = added;\n        this.attributeOldValues = attributeOldValues;\n        this.characterDataOldValue = characterDataOldValue;\n        this.isCaseInsensitive =\n            this.node.nodeType === Node.ELEMENT_NODE &&\n                this.node instanceof HTMLElement &&\n                this.node.ownerDocument instanceof HTMLDocument;\n    }\n    NodeChange.prototype.getAttributeOldValue = function (name) {\n        if (!this.attributeOldValues)\n            return undefined;\n        if (this.isCaseInsensitive)\n            name = name.toLowerCase();\n        return this.attributeOldValues[name];\n    };\n    NodeChange.prototype.getAttributeNamesMutated = function () {\n        var names = [];\n        if (!this.attributeOldValues)\n            return names;\n        for (var name in this.attributeOldValues) {\n            names.push(name);\n        }\n        return names;\n    };\n    NodeChange.prototype.attributeMutated = function (name, oldValue) {\n        this.attributes = true;\n        this.attributeOldValues = this.attributeOldValues || {};\n        if (name in this.attributeOldValues)\n            return;\n        this.attributeOldValues[name] = oldValue;\n    };\n    NodeChange.prototype.characterDataMutated = function (oldValue) {\n        if (this.characterData)\n            return;\n        this.characterData = true;\n        this.characterDataOldValue = oldValue;\n    };\n    // Note: is it possible to receive a removal followed by a removal. This\n    // can occur if the removed node is added to an non-observed node, that\n    // node is added to the observed area, and then the node removed from\n    // it.\n    NodeChange.prototype.removedFromParent = function (parent) {\n        this.childList = true;\n        if (this.added || this.oldParentNode)\n            this.added = false;\n        else\n            this.oldParentNode = parent;\n    };\n    NodeChange.prototype.insertedIntoParent = function () {\n        this.childList = true;\n        this.added = true;\n    };\n    // An node's oldParent is\n    //   -its present parent, if its parentNode was not changed.\n    //   -null if the first thing that happened to it was an add.\n    //   -the node it was removed from if the first thing that happened to it\n    //      was a remove.\n    NodeChange.prototype.getOldParent = function () {\n        if (this.childList) {\n            if (this.oldParentNode)\n                return this.oldParentNode;\n            if (this.added)\n                return null;\n        }\n        return this.node.parentNode;\n    };\n    return NodeChange;\n})();\nvar ChildListChange = (function () {\n    function ChildListChange() {\n        this.added = new NodeMap();\n        this.removed = new NodeMap();\n        this.maybeMoved = new NodeMap();\n        this.oldPrevious = new NodeMap();\n        this.moved = undefined;\n    }\n    return ChildListChange;\n})();\nvar TreeChanges = (function (_super) {\n    __extends(TreeChanges, _super);\n    function TreeChanges(rootNode, mutations) {\n        _super.call(this);\n        this.rootNode = rootNode;\n        this.reachableCache = undefined;\n        this.wasReachableCache = undefined;\n        this.anyParentsChanged = false;\n        this.anyAttributesChanged = false;\n        this.anyCharacterDataChanged = false;\n        for (var m = 0; m < mutations.length; m++) {\n            var mutation = mutations[m];\n            switch (mutation.type) {\n                case 'childList':\n                    this.anyParentsChanged = true;\n                    for (var i = 0; i < mutation.removedNodes.length; i++) {\n                        var node = mutation.removedNodes[i];\n                        this.getChange(node).removedFromParent(mutation.target);\n                    }\n                    for (var i = 0; i < mutation.addedNodes.length; i++) {\n                        var node = mutation.addedNodes[i];\n                        this.getChange(node).insertedIntoParent();\n                    }\n                    break;\n                case 'attributes':\n                    this.anyAttributesChanged = true;\n                    var change = this.getChange(mutation.target);\n                    change.attributeMutated(mutation.attributeName, mutation.oldValue);\n                    break;\n                case 'characterData':\n                    this.anyCharacterDataChanged = true;\n                    var change = this.getChange(mutation.target);\n                    change.characterDataMutated(mutation.oldValue);\n                    break;\n            }\n        }\n    }\n    TreeChanges.prototype.getChange = function (node) {\n        var change = this.get(node);\n        if (!change) {\n            change = new NodeChange(node);\n            this.set(node, change);\n        }\n        return change;\n    };\n    TreeChanges.prototype.getOldParent = function (node) {\n        var change = this.get(node);\n        return change ? change.getOldParent() : node.parentNode;\n    };\n    TreeChanges.prototype.getIsReachable = function (node) {\n        if (node === this.rootNode)\n            return true;\n        if (!node)\n            return false;\n        this.reachableCache = this.reachableCache || new NodeMap();\n        var isReachable = this.reachableCache.get(node);\n        if (isReachable === undefined) {\n            isReachable = this.getIsReachable(node.parentNode);\n            this.reachableCache.set(node, isReachable);\n        }\n        return isReachable;\n    };\n    // A node wasReachable if its oldParent wasReachable.\n    TreeChanges.prototype.getWasReachable = function (node) {\n        if (node === this.rootNode)\n            return true;\n        if (!node)\n            return false;\n        this.wasReachableCache = this.wasReachableCache || new NodeMap();\n        var wasReachable = this.wasReachableCache.get(node);\n        if (wasReachable === undefined) {\n            wasReachable = this.getWasReachable(this.getOldParent(node));\n            this.wasReachableCache.set(node, wasReachable);\n        }\n        return wasReachable;\n    };\n    TreeChanges.prototype.reachabilityChange = function (node) {\n        if (this.getIsReachable(node)) {\n            return this.getWasReachable(node) ?\n                Movement.STAYED_IN : Movement.ENTERED;\n        }\n        return this.getWasReachable(node) ?\n            Movement.EXITED : Movement.STAYED_OUT;\n    };\n    return TreeChanges;\n})(NodeMap);\nvar MutationProjection = (function () {\n    // TOOD(any)\n    function MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {\n        this.rootNode = rootNode;\n        this.mutations = mutations;\n        this.selectors = selectors;\n        this.calcReordered = calcReordered;\n        this.calcOldPreviousSibling = calcOldPreviousSibling;\n        this.treeChanges = new TreeChanges(rootNode, mutations);\n        this.entered = [];\n        this.exited = [];\n        this.stayedIn = new NodeMap();\n        this.visited = new NodeMap();\n        this.childListChangeMap = undefined;\n        this.characterDataOnly = undefined;\n        this.matchCache = undefined;\n        this.processMutations();\n    }\n    MutationProjection.prototype.processMutations = function () {\n        if (!this.treeChanges.anyParentsChanged &&\n            !this.treeChanges.anyAttributesChanged)\n            return;\n        var changedNodes = this.treeChanges.keys();\n        for (var i = 0; i < changedNodes.length; i++) {\n            this.visitNode(changedNodes[i], undefined);\n        }\n    };\n    MutationProjection.prototype.visitNode = function (node, parentReachable) {\n        if (this.visited.has(node))\n            return;\n        this.visited.set(node, true);\n        var change = this.treeChanges.get(node);\n        var reachable = parentReachable;\n        // node inherits its parent's reachability change unless\n        // its parentNode was mutated.\n        if ((change && change.childList) || reachable == undefined)\n            reachable = this.treeChanges.reachabilityChange(node);\n        if (reachable === Movement.STAYED_OUT)\n            return;\n        // Cache match results for sub-patterns.\n        this.matchabilityChange(node);\n        if (reachable === Movement.ENTERED) {\n            this.entered.push(node);\n        }\n        else if (reachable === Movement.EXITED) {\n            this.exited.push(node);\n            this.ensureHasOldPreviousSiblingIfNeeded(node);\n        }\n        else if (reachable === Movement.STAYED_IN) {\n            var movement = Movement.STAYED_IN;\n            if (change && change.childList) {\n                if (change.oldParentNode !== node.parentNode) {\n                    movement = Movement.REPARENTED;\n                    this.ensureHasOldPreviousSiblingIfNeeded(node);\n                }\n                else if (this.calcReordered && this.wasReordered(node)) {\n                    movement = Movement.REORDERED;\n                }\n            }\n            this.stayedIn.set(node, movement);\n        }\n        if (reachable === Movement.STAYED_IN)\n            return;\n        // reachable === ENTERED || reachable === EXITED.\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n            this.visitNode(child, reachable);\n        }\n    };\n    MutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {\n        if (!this.calcOldPreviousSibling)\n            return;\n        this.processChildlistChanges();\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change) {\n            change = new ChildListChange();\n            this.childListChangeMap.set(parentNode, change);\n        }\n        if (!change.oldPrevious.has(node)) {\n            change.oldPrevious.set(node, node.previousSibling);\n        }\n    };\n    MutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {\n        this.selectors = selectors;\n        this.characterDataOnly = characterDataOnly;\n        for (var i = 0; i < this.entered.length; i++) {\n            var node = this.entered[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === Movement.ENTERED || matchable === Movement.STAYED_IN)\n                summary.added.push(node);\n        }\n        var stayedInNodes = this.stayedIn.keys();\n        for (var i = 0; i < stayedInNodes.length; i++) {\n            var node = stayedInNodes[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === Movement.ENTERED) {\n                summary.added.push(node);\n            }\n            else if (matchable === Movement.EXITED) {\n                summary.removed.push(node);\n            }\n            else if (matchable === Movement.STAYED_IN && (summary.reparented || summary.reordered)) {\n                var movement = this.stayedIn.get(node);\n                if (summary.reparented && movement === Movement.REPARENTED)\n                    summary.reparented.push(node);\n                else if (summary.reordered && movement === Movement.REORDERED)\n                    summary.reordered.push(node);\n            }\n        }\n        for (var i = 0; i < this.exited.length; i++) {\n            var node = this.exited[i];\n            var matchable = this.matchabilityChange(node);\n            if (matchable === Movement.EXITED || matchable === Movement.STAYED_IN)\n                summary.removed.push(node);\n        }\n    };\n    MutationProjection.prototype.getOldParentNode = function (node) {\n        var change = this.treeChanges.get(node);\n        if (change && change.childList)\n            return change.oldParentNode ? change.oldParentNode : null;\n        var reachabilityChange = this.treeChanges.reachabilityChange(node);\n        if (reachabilityChange === Movement.STAYED_OUT || reachabilityChange === Movement.ENTERED)\n            throw Error('getOldParentNode requested on invalid node.');\n        return node.parentNode;\n    };\n    MutationProjection.prototype.getOldPreviousSibling = function (node) {\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change)\n            throw Error('getOldPreviousSibling requested on invalid node.');\n        return change.oldPrevious.get(node);\n    };\n    MutationProjection.prototype.getOldAttribute = function (element, attrName) {\n        var change = this.treeChanges.get(element);\n        if (!change || !change.attributes)\n            throw Error('getOldAttribute requested on invalid node.');\n        var value = change.getAttributeOldValue(attrName);\n        if (value === undefined)\n            throw Error('getOldAttribute requested for unchanged attribute name.');\n        return value;\n    };\n    MutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {\n        if (!this.treeChanges.anyAttributesChanged)\n            return {}; // No attributes mutations occurred.\n        var attributeFilter;\n        var caseInsensitiveFilter;\n        if (includeAttributes) {\n            attributeFilter = {};\n            caseInsensitiveFilter = {};\n            for (var i = 0; i < includeAttributes.length; i++) {\n                var attrName = includeAttributes[i];\n                attributeFilter[attrName] = true;\n                caseInsensitiveFilter[attrName.toLowerCase()] = attrName;\n            }\n        }\n        var result = {};\n        var nodes = this.treeChanges.keys();\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            var change = this.treeChanges.get(node);\n            if (!change.attributes)\n                continue;\n            if (Movement.STAYED_IN !== this.treeChanges.reachabilityChange(node) ||\n                Movement.STAYED_IN !== this.matchabilityChange(node)) {\n                continue;\n            }\n            var element = node;\n            var changedAttrNames = change.getAttributeNamesMutated();\n            for (var j = 0; j < changedAttrNames.length; j++) {\n                var attrName = changedAttrNames[j];\n                if (attributeFilter &&\n                    !attributeFilter[attrName] &&\n                    !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {\n                    continue;\n                }\n                var oldValue = change.getAttributeOldValue(attrName);\n                if (oldValue === element.getAttribute(attrName))\n                    continue;\n                if (caseInsensitiveFilter && change.isCaseInsensitive)\n                    attrName = caseInsensitiveFilter[attrName];\n                result[attrName] = result[attrName] || [];\n                result[attrName].push(element);\n            }\n        }\n        return result;\n    };\n    MutationProjection.prototype.getOldCharacterData = function (node) {\n        var change = this.treeChanges.get(node);\n        if (!change || !change.characterData)\n            throw Error('getOldCharacterData requested on invalid node.');\n        return change.characterDataOldValue;\n    };\n    MutationProjection.prototype.getCharacterDataChanged = function () {\n        if (!this.treeChanges.anyCharacterDataChanged)\n            return []; // No characterData mutations occurred.\n        var nodes = this.treeChanges.keys();\n        var result = [];\n        for (var i = 0; i < nodes.length; i++) {\n            var target = nodes[i];\n            if (Movement.STAYED_IN !== this.treeChanges.reachabilityChange(target))\n                continue;\n            var change = this.treeChanges.get(target);\n            if (!change.characterData ||\n                target.textContent == change.characterDataOldValue)\n                continue;\n            result.push(target);\n        }\n        return result;\n    };\n    MutationProjection.prototype.computeMatchabilityChange = function (selector, el) {\n        if (!this.matchCache)\n            this.matchCache = [];\n        if (!this.matchCache[selector.uid])\n            this.matchCache[selector.uid] = new NodeMap();\n        var cache = this.matchCache[selector.uid];\n        var result = cache.get(el);\n        if (result === undefined) {\n            result = selector.matchabilityChange(el, this.treeChanges.get(el));\n            cache.set(el, result);\n        }\n        return result;\n    };\n    MutationProjection.prototype.matchabilityChange = function (node) {\n        var _this = this;\n        // TODO(rafaelw): Include PI, CDATA?\n        // Only include text nodes.\n        if (this.characterDataOnly) {\n            switch (node.nodeType) {\n                case Node.COMMENT_NODE:\n                case Node.TEXT_NODE:\n                    return Movement.STAYED_IN;\n                default:\n                    return Movement.STAYED_OUT;\n            }\n        }\n        // No element filter. Include all nodes.\n        if (!this.selectors)\n            return Movement.STAYED_IN;\n        // Element filter. Exclude non-elements.\n        if (node.nodeType !== Node.ELEMENT_NODE)\n            return Movement.STAYED_OUT;\n        var el = node;\n        var matchChanges = this.selectors.map(function (selector) {\n            return _this.computeMatchabilityChange(selector, el);\n        });\n        var accum = Movement.STAYED_OUT;\n        var i = 0;\n        while (accum !== Movement.STAYED_IN && i < matchChanges.length) {\n            switch (matchChanges[i]) {\n                case Movement.STAYED_IN:\n                    accum = Movement.STAYED_IN;\n                    break;\n                case Movement.ENTERED:\n                    if (accum === Movement.EXITED)\n                        accum = Movement.STAYED_IN;\n                    else\n                        accum = Movement.ENTERED;\n                    break;\n                case Movement.EXITED:\n                    if (accum === Movement.ENTERED)\n                        accum = Movement.STAYED_IN;\n                    else\n                        accum = Movement.EXITED;\n                    break;\n            }\n            i++;\n        }\n        return accum;\n    };\n    MutationProjection.prototype.getChildlistChange = function (el) {\n        var change = this.childListChangeMap.get(el);\n        if (!change) {\n            change = new ChildListChange();\n            this.childListChangeMap.set(el, change);\n        }\n        return change;\n    };\n    MutationProjection.prototype.processChildlistChanges = function () {\n        if (this.childListChangeMap)\n            return;\n        this.childListChangeMap = new NodeMap();\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.type != 'childList')\n                continue;\n            if (this.treeChanges.reachabilityChange(mutation.target) !== Movement.STAYED_IN &&\n                !this.calcOldPreviousSibling)\n                continue;\n            var change = this.getChildlistChange(mutation.target);\n            var oldPrevious = mutation.previousSibling;\n            function recordOldPrevious(node, previous) {\n                if (!node ||\n                    change.oldPrevious.has(node) ||\n                    change.added.has(node) ||\n                    change.maybeMoved.has(node))\n                    return;\n                if (previous &&\n                    (change.added.has(previous) ||\n                        change.maybeMoved.has(previous)))\n                    return;\n                change.oldPrevious.set(node, previous);\n            }\n            for (var j = 0; j < mutation.removedNodes.length; j++) {\n                var node = mutation.removedNodes[j];\n                recordOldPrevious(node, oldPrevious);\n                if (change.added.has(node)) {\n                    change.added.delete(node);\n                }\n                else {\n                    change.removed.set(node, true);\n                    change.maybeMoved.delete(node);\n                }\n                oldPrevious = node;\n            }\n            recordOldPrevious(mutation.nextSibling, oldPrevious);\n            for (var j = 0; j < mutation.addedNodes.length; j++) {\n                var node = mutation.addedNodes[j];\n                if (change.removed.has(node)) {\n                    change.removed.delete(node);\n                    change.maybeMoved.set(node, true);\n                }\n                else {\n                    change.added.set(node, true);\n                }\n            }\n        }\n    };\n    MutationProjection.prototype.wasReordered = function (node) {\n        if (!this.treeChanges.anyParentsChanged)\n            return false;\n        this.processChildlistChanges();\n        var parentNode = node.parentNode;\n        var nodeChange = this.treeChanges.get(node);\n        if (nodeChange && nodeChange.oldParentNode)\n            parentNode = nodeChange.oldParentNode;\n        var change = this.childListChangeMap.get(parentNode);\n        if (!change)\n            return false;\n        if (change.moved)\n            return change.moved.get(node);\n        change.moved = new NodeMap();\n        var pendingMoveDecision = new NodeMap();\n        function isMoved(node) {\n            if (!node)\n                return false;\n            if (!change.maybeMoved.has(node))\n                return false;\n            var didMove = change.moved.get(node);\n            if (didMove !== undefined)\n                return didMove;\n            if (pendingMoveDecision.has(node)) {\n                didMove = true;\n            }\n            else {\n                pendingMoveDecision.set(node, true);\n                didMove = getPrevious(node) !== getOldPrevious(node);\n            }\n            if (pendingMoveDecision.has(node)) {\n                pendingMoveDecision.delete(node);\n                change.moved.set(node, didMove);\n            }\n            else {\n                didMove = change.moved.get(node);\n            }\n            return didMove;\n        }\n        var oldPreviousCache = new NodeMap();\n        function getOldPrevious(node) {\n            var oldPrevious = oldPreviousCache.get(node);\n            if (oldPrevious !== undefined)\n                return oldPrevious;\n            oldPrevious = change.oldPrevious.get(node);\n            while (oldPrevious &&\n                (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {\n                oldPrevious = getOldPrevious(oldPrevious);\n            }\n            if (oldPrevious === undefined)\n                oldPrevious = node.previousSibling;\n            oldPreviousCache.set(node, oldPrevious);\n            return oldPrevious;\n        }\n        var previousCache = new NodeMap();\n        function getPrevious(node) {\n            if (previousCache.has(node))\n                return previousCache.get(node);\n            var previous = node.previousSibling;\n            while (previous && (change.added.has(previous) || isMoved(previous)))\n                previous = previous.previousSibling;\n            previousCache.set(node, previous);\n            return previous;\n        }\n        change.maybeMoved.keys().forEach(isMoved);\n        return change.moved.get(node);\n    };\n    return MutationProjection;\n})();\nvar Summary = (function () {\n    function Summary(projection, query) {\n        var _this = this;\n        this.projection = projection;\n        this.added = [];\n        this.removed = [];\n        this.reparented = query.all || query.element || query.characterData ? [] : undefined;\n        this.reordered = query.all ? [] : undefined;\n        projection.getChanged(this, query.elementFilter, query.characterData);\n        if (query.all || query.attribute || query.attributeList) {\n            var filter = query.attribute ? [query.attribute] : query.attributeList;\n            var attributeChanged = projection.attributeChangedNodes(filter);\n            if (query.attribute) {\n                this.valueChanged = attributeChanged[query.attribute] || [];\n            }\n            else {\n                this.attributeChanged = attributeChanged;\n                if (query.attributeList) {\n                    query.attributeList.forEach(function (attrName) {\n                        if (!_this.attributeChanged.hasOwnProperty(attrName))\n                            _this.attributeChanged[attrName] = [];\n                    });\n                }\n            }\n        }\n        if (query.all || query.characterData) {\n            var characterDataChanged = projection.getCharacterDataChanged();\n            if (query.characterData)\n                this.valueChanged = characterDataChanged;\n            else\n                this.characterDataChanged = characterDataChanged;\n        }\n        if (this.reordered)\n            this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);\n    }\n    Summary.prototype.getOldParentNode = function (node) {\n        return this.projection.getOldParentNode(node);\n    };\n    Summary.prototype.getOldAttribute = function (node, name) {\n        return this.projection.getOldAttribute(node, name);\n    };\n    Summary.prototype.getOldCharacterData = function (node) {\n        return this.projection.getOldCharacterData(node);\n    };\n    Summary.prototype.getOldPreviousSibling = function (node) {\n        return this.projection.getOldPreviousSibling(node);\n    };\n    return Summary;\n})();\n// TODO(rafaelw): Allow ':' and '.' as valid name characters.\nvar validNameInitialChar = /[a-zA-Z_]+/;\nvar validNameNonInitialChar = /[a-zA-Z0-9_\\-]+/;\n// TODO(rafaelw): Consider allowing backslash in the attrValue.\n// TODO(rafaelw): There's got a to be way to represent this state machine\n// more compactly???\nfunction escapeQuotes(value) {\n    return '\"' + value.replace(/\"/, '\\\\\\\"') + '\"';\n}\nvar Qualifier = (function () {\n    function Qualifier() {\n    }\n    Qualifier.prototype.matches = function (oldValue) {\n        if (oldValue === null)\n            return false;\n        if (this.attrValue === undefined)\n            return true;\n        if (!this.contains)\n            return this.attrValue == oldValue;\n        var tokens = oldValue.split(' ');\n        for (var i = 0; i < tokens.length; i++) {\n            if (this.attrValue === tokens[i])\n                return true;\n        }\n        return false;\n    };\n    Qualifier.prototype.toString = function () {\n        if (this.attrName === 'class' && this.contains)\n            return '.' + this.attrValue;\n        if (this.attrName === 'id' && !this.contains)\n            return '#' + this.attrValue;\n        if (this.contains)\n            return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';\n        if ('attrValue' in this)\n            return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';\n        return '[' + this.attrName + ']';\n    };\n    return Qualifier;\n})();\nvar Selector = (function () {\n    function Selector() {\n        this.uid = Selector.nextUid++;\n        this.qualifiers = [];\n    }\n    Object.defineProperty(Selector.prototype, \"caseInsensitiveTagName\", {\n        get: function () {\n            return this.tagName.toUpperCase();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Selector.prototype, \"selectorString\", {\n        get: function () {\n            return this.tagName + this.qualifiers.join('');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Selector.prototype.isMatching = function (el) {\n        return el[Selector.matchesSelector](this.selectorString);\n    };\n    Selector.prototype.wasMatching = function (el, change, isMatching) {\n        if (!change || !change.attributes)\n            return isMatching;\n        var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;\n        if (tagName !== '*' && tagName !== el.tagName)\n            return false;\n        var attributeOldValues = [];\n        var anyChanged = false;\n        for (var i = 0; i < this.qualifiers.length; i++) {\n            var qualifier = this.qualifiers[i];\n            var oldValue = change.getAttributeOldValue(qualifier.attrName);\n            attributeOldValues.push(oldValue);\n            anyChanged = anyChanged || (oldValue !== undefined);\n        }\n        if (!anyChanged)\n            return isMatching;\n        for (var i = 0; i < this.qualifiers.length; i++) {\n            var qualifier = this.qualifiers[i];\n            var oldValue = attributeOldValues[i];\n            if (oldValue === undefined)\n                oldValue = el.getAttribute(qualifier.attrName);\n            if (!qualifier.matches(oldValue))\n                return false;\n        }\n        return true;\n    };\n    Selector.prototype.matchabilityChange = function (el, change) {\n        var isMatching = this.isMatching(el);\n        if (isMatching)\n            return this.wasMatching(el, change, isMatching) ? Movement.STAYED_IN : Movement.ENTERED;\n        else\n            return this.wasMatching(el, change, isMatching) ? Movement.EXITED : Movement.STAYED_OUT;\n    };\n    Selector.parseSelectors = function (input) {\n        var selectors = [];\n        var currentSelector;\n        var currentQualifier;\n        function newSelector() {\n            if (currentSelector) {\n                if (currentQualifier) {\n                    currentSelector.qualifiers.push(currentQualifier);\n                    currentQualifier = undefined;\n                }\n                selectors.push(currentSelector);\n            }\n            currentSelector = new Selector();\n        }\n        function newQualifier() {\n            if (currentQualifier)\n                currentSelector.qualifiers.push(currentQualifier);\n            currentQualifier = new Qualifier();\n        }\n        var WHITESPACE = /\\s/;\n        var valueQuoteChar;\n        var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';\n        var SELECTOR = 1;\n        var TAG_NAME = 2;\n        var QUALIFIER = 3;\n        var QUALIFIER_NAME_FIRST_CHAR = 4;\n        var QUALIFIER_NAME = 5;\n        var ATTR_NAME_FIRST_CHAR = 6;\n        var ATTR_NAME = 7;\n        var EQUIV_OR_ATTR_QUAL_END = 8;\n        var EQUAL = 9;\n        var ATTR_QUAL_END = 10;\n        var VALUE_FIRST_CHAR = 11;\n        var VALUE = 12;\n        var QUOTED_VALUE = 13;\n        var SELECTOR_SEPARATOR = 14;\n        var state = SELECTOR;\n        var i = 0;\n        while (i < input.length) {\n            var c = input[i++];\n            switch (state) {\n                case SELECTOR:\n                    if (c.match(validNameInitialChar)) {\n                        newSelector();\n                        currentSelector.tagName = c;\n                        state = TAG_NAME;\n                        break;\n                    }\n                    if (c == '*') {\n                        newSelector();\n                        currentSelector.tagName = '*';\n                        state = QUALIFIER;\n                        break;\n                    }\n                    if (c == '.') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newSelector();\n                        newQualifier();\n                        currentSelector.tagName = '*';\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c.match(WHITESPACE))\n                        break;\n                    throw Error(SYNTAX_ERROR);\n                case TAG_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentSelector.tagName += c;\n                        break;\n                    }\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n                case QUALIFIER:\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        currentQualifier.attrName = '';\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n                case QUALIFIER_NAME_FIRST_CHAR:\n                    if (c.match(validNameInitialChar)) {\n                        currentQualifier.attrValue = c;\n                        state = QUALIFIER_NAME;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n                case QUALIFIER_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentQualifier.attrValue += c;\n                        break;\n                    }\n                    if (c == '.') {\n                        newQualifier();\n                        currentQualifier.attrName = 'class';\n                        currentQualifier.contains = true;\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '#') {\n                        newQualifier();\n                        currentQualifier.attrName = 'id';\n                        state = QUALIFIER_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == '[') {\n                        newQualifier();\n                        state = ATTR_NAME_FIRST_CHAR;\n                        break;\n                    }\n                    if (c.match(WHITESPACE)) {\n                        state = SELECTOR_SEPARATOR;\n                        break;\n                    }\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n                case ATTR_NAME_FIRST_CHAR:\n                    if (c.match(validNameInitialChar)) {\n                        currentQualifier.attrName = c;\n                        state = ATTR_NAME;\n                        break;\n                    }\n                    if (c.match(WHITESPACE))\n                        break;\n                    throw Error(SYNTAX_ERROR);\n                case ATTR_NAME:\n                    if (c.match(validNameNonInitialChar)) {\n                        currentQualifier.attrName += c;\n                        break;\n                    }\n                    if (c.match(WHITESPACE)) {\n                        state = EQUIV_OR_ATTR_QUAL_END;\n                        break;\n                    }\n                    if (c == '~') {\n                        currentQualifier.contains = true;\n                        state = EQUAL;\n                        break;\n                    }\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n                case EQUIV_OR_ATTR_QUAL_END:\n                    if (c == '~') {\n                        currentQualifier.contains = true;\n                        state = EQUAL;\n                        break;\n                    }\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n                    if (c.match(WHITESPACE))\n                        break;\n                    throw Error(SYNTAX_ERROR);\n                case EQUAL:\n                    if (c == '=') {\n                        currentQualifier.attrValue = '';\n                        state = VALUE_FIRST_CHAR;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n                case ATTR_QUAL_END:\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n                    if (c.match(WHITESPACE))\n                        break;\n                    throw Error(SYNTAX_ERROR);\n                case VALUE_FIRST_CHAR:\n                    if (c.match(WHITESPACE))\n                        break;\n                    if (c == '\"' || c == \"'\") {\n                        valueQuoteChar = c;\n                        state = QUOTED_VALUE;\n                        break;\n                    }\n                    currentQualifier.attrValue += c;\n                    state = VALUE;\n                    break;\n                case VALUE:\n                    if (c.match(WHITESPACE)) {\n                        state = ATTR_QUAL_END;\n                        break;\n                    }\n                    if (c == ']') {\n                        state = QUALIFIER;\n                        break;\n                    }\n                    if (c == \"'\" || c == '\"')\n                        throw Error(SYNTAX_ERROR);\n                    currentQualifier.attrValue += c;\n                    break;\n                case QUOTED_VALUE:\n                    if (c == valueQuoteChar) {\n                        state = ATTR_QUAL_END;\n                        break;\n                    }\n                    currentQualifier.attrValue += c;\n                    break;\n                case SELECTOR_SEPARATOR:\n                    if (c.match(WHITESPACE))\n                        break;\n                    if (c == ',') {\n                        state = SELECTOR;\n                        break;\n                    }\n                    throw Error(SYNTAX_ERROR);\n            }\n        }\n        switch (state) {\n            case SELECTOR:\n            case TAG_NAME:\n            case QUALIFIER:\n            case QUALIFIER_NAME:\n            case SELECTOR_SEPARATOR:\n                // Valid end states.\n                newSelector();\n                break;\n            default:\n                throw Error(SYNTAX_ERROR);\n        }\n        if (!selectors.length)\n            throw Error(SYNTAX_ERROR);\n        return selectors;\n    };\n    Selector.nextUid = 1;\n    Selector.matchesSelector = (function () {\n        var element = document.createElement('div');\n        if (typeof element['webkitMatchesSelector'] === 'function')\n            return 'webkitMatchesSelector';\n        if (typeof element['mozMatchesSelector'] === 'function')\n            return 'mozMatchesSelector';\n        if (typeof element['msMatchesSelector'] === 'function')\n            return 'msMatchesSelector';\n        return 'matchesSelector';\n    })();\n    return Selector;\n})();\nvar attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\\-:\\.]*)$/;\nfunction validateAttribute(attribute) {\n    if (typeof attribute != 'string')\n        throw Error('Invalid request opion. attribute must be a non-zero length string.');\n    attribute = attribute.trim();\n    if (!attribute)\n        throw Error('Invalid request opion. attribute must be a non-zero length string.');\n    if (!attribute.match(attributeFilterPattern))\n        throw Error('Invalid request option. invalid attribute name: ' + attribute);\n    return attribute;\n}\nfunction validateElementAttributes(attribs) {\n    if (!attribs.trim().length)\n        throw Error('Invalid request option: elementAttributes must contain at least one attribute.');\n    var lowerAttributes = {};\n    var attributes = {};\n    var tokens = attribs.split(/\\s+/);\n    for (var i = 0; i < tokens.length; i++) {\n        var name = tokens[i];\n        if (!name)\n            continue;\n        var name = validateAttribute(name);\n        var nameLower = name.toLowerCase();\n        if (lowerAttributes[nameLower])\n            throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');\n        attributes[name] = true;\n        lowerAttributes[nameLower] = true;\n    }\n    return Object.keys(attributes);\n}\nfunction elementFilterAttributes(selectors) {\n    var attributes = {};\n    selectors.forEach(function (selector) {\n        selector.qualifiers.forEach(function (qualifier) {\n            attributes[qualifier.attrName] = true;\n        });\n    });\n    return Object.keys(attributes);\n}\nvar MutationSummary = (function () {\n    function MutationSummary(opts) {\n        var _this = this;\n        this.connected = false;\n        this.options = MutationSummary.validateOptions(opts);\n        this.observerOptions = MutationSummary.createObserverOptions(this.options.queries);\n        this.root = this.options.rootNode;\n        this.callback = this.options.callback;\n        this.elementFilter = Array.prototype.concat.apply([], this.options.queries.map(function (query) {\n            return query.elementFilter ? query.elementFilter : [];\n        }));\n        if (!this.elementFilter.length)\n            this.elementFilter = undefined;\n        this.calcReordered = this.options.queries.some(function (query) {\n            return query.all;\n        });\n        this.queryValidators = []; // TODO(rafaelw): Shouldn't always define this.\n        if (MutationSummary.createQueryValidator) {\n            this.queryValidators = this.options.queries.map(function (query) {\n                return MutationSummary.createQueryValidator(_this.root, query);\n            });\n        }\n        this.observer = new MutationObserverCtor(function (mutations) {\n            _this.observerCallback(mutations);\n        });\n        this.reconnect();\n    }\n    MutationSummary.createObserverOptions = function (queries) {\n        var observerOptions = {\n            childList: true,\n            subtree: true\n        };\n        var attributeFilter;\n        function observeAttributes(attributes) {\n            if (observerOptions.attributes && !attributeFilter)\n                return; // already observing all.\n            observerOptions.attributes = true;\n            observerOptions.attributeOldValue = true;\n            if (!attributes) {\n                // observe all.\n                attributeFilter = undefined;\n                return;\n            }\n            // add to observed.\n            attributeFilter = attributeFilter || {};\n            attributes.forEach(function (attribute) {\n                attributeFilter[attribute] = true;\n                attributeFilter[attribute.toLowerCase()] = true;\n            });\n        }\n        queries.forEach(function (query) {\n            if (query.characterData) {\n                observerOptions.characterData = true;\n                observerOptions.characterDataOldValue = true;\n                return;\n            }\n            if (query.all) {\n                observeAttributes();\n                observerOptions.characterData = true;\n                observerOptions.characterDataOldValue = true;\n                return;\n            }\n            if (query.attribute) {\n                observeAttributes([query.attribute.trim()]);\n                return;\n            }\n            var attributes = elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);\n            if (attributes.length)\n                observeAttributes(attributes);\n        });\n        if (attributeFilter)\n            observerOptions.attributeFilter = Object.keys(attributeFilter);\n        return observerOptions;\n    };\n    MutationSummary.validateOptions = function (options) {\n        for (var prop in options) {\n            if (!(prop in MutationSummary.optionKeys))\n                throw Error('Invalid option: ' + prop);\n        }\n        if (typeof options.callback !== 'function')\n            throw Error('Invalid options: callback is required and must be a function');\n        if (!options.queries || !options.queries.length)\n            throw Error('Invalid options: queries must contain at least one query request object.');\n        var opts = {\n            callback: options.callback,\n            rootNode: options.rootNode || document,\n            observeOwnChanges: !!options.observeOwnChanges,\n            oldPreviousSibling: !!options.oldPreviousSibling,\n            queries: []\n        };\n        for (var i = 0; i < options.queries.length; i++) {\n            var request = options.queries[i];\n            // all\n            if (request.all) {\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. all has no options.');\n                opts.queries.push({ all: true });\n                continue;\n            }\n            // attribute\n            if ('attribute' in request) {\n                var query = {\n                    attribute: validateAttribute(request.attribute)\n                };\n                query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. attribute has no options.');\n                opts.queries.push(query);\n                continue;\n            }\n            // element\n            if ('element' in request) {\n                var requestOptionCount = Object.keys(request).length;\n                var query = {\n                    element: request.element,\n                    elementFilter: Selector.parseSelectors(request.element)\n                };\n                if (request.hasOwnProperty('elementAttributes')) {\n                    query.attributeList = validateElementAttributes(request.elementAttributes);\n                    requestOptionCount--;\n                }\n                if (requestOptionCount > 1)\n                    throw Error('Invalid request option. element only allows elementAttributes option.');\n                opts.queries.push(query);\n                continue;\n            }\n            // characterData\n            if (request.characterData) {\n                if (Object.keys(request).length > 1)\n                    throw Error('Invalid request option. characterData has no options.');\n                opts.queries.push({ characterData: true });\n                continue;\n            }\n            throw Error('Invalid request option. Unknown query request.');\n        }\n        return opts;\n    };\n    MutationSummary.prototype.createSummaries = function (mutations) {\n        if (!mutations || !mutations.length)\n            return [];\n        var projection = new MutationProjection(this.root, mutations, this.elementFilter, this.calcReordered, this.options.oldPreviousSibling);\n        var summaries = [];\n        for (var i = 0; i < this.options.queries.length; i++) {\n            summaries.push(new Summary(projection, this.options.queries[i]));\n        }\n        return summaries;\n    };\n    MutationSummary.prototype.checkpointQueryValidators = function () {\n        this.queryValidators.forEach(function (validator) {\n            if (validator)\n                validator.recordPreviousState();\n        });\n    };\n    MutationSummary.prototype.runQueryValidators = function (summaries) {\n        this.queryValidators.forEach(function (validator, index) {\n            if (validator)\n                validator.validate(summaries[index]);\n        });\n    };\n    MutationSummary.prototype.changesToReport = function (summaries) {\n        return summaries.some(function (summary) {\n            var summaryProps = ['added', 'removed', 'reordered', 'reparented',\n                'valueChanged', 'characterDataChanged'];\n            if (summaryProps.some(function (prop) { return summary[prop] && summary[prop].length; }))\n                return true;\n            if (summary.attributeChanged) {\n                var attrNames = Object.keys(summary.attributeChanged);\n                var attrsChanged = attrNames.some(function (attrName) {\n                    return !!summary.attributeChanged[attrName].length;\n                });\n                if (attrsChanged)\n                    return true;\n            }\n            return false;\n        });\n    };\n    MutationSummary.prototype.observerCallback = function (mutations) {\n        if (!this.options.observeOwnChanges)\n            this.observer.disconnect();\n        var summaries = this.createSummaries(mutations);\n        this.runQueryValidators(summaries);\n        if (this.options.observeOwnChanges)\n            this.checkpointQueryValidators();\n        if (this.changesToReport(summaries))\n            this.callback(summaries);\n        // disconnect() may have been called during the callback.\n        if (!this.options.observeOwnChanges && this.connected) {\n            this.checkpointQueryValidators();\n            this.observer.observe(this.root, this.observerOptions);\n        }\n    };\n    MutationSummary.prototype.reconnect = function () {\n        if (this.connected)\n            throw Error('Already connected');\n        this.observer.observe(this.root, this.observerOptions);\n        this.connected = true;\n        this.checkpointQueryValidators();\n    };\n    MutationSummary.prototype.takeSummaries = function () {\n        if (!this.connected)\n            throw Error('Not connected');\n        var summaries = this.createSummaries(this.observer.takeRecords());\n        return this.changesToReport(summaries) ? summaries : undefined;\n    };\n    MutationSummary.prototype.disconnect = function () {\n        var summaries = this.takeSummaries();\n        this.observer.disconnect();\n        this.connected = false;\n        return summaries;\n    };\n    MutationSummary.NodeMap = NodeMap; // exposed for use in TreeMirror.\n    MutationSummary.parseElementFilter = Selector.parseSelectors; // exposed for testing.\n    MutationSummary.optionKeys = {\n        'callback': true,\n        'queries': true,\n        'rootNode': true,\n        'oldPreviousSibling': true,\n        'observeOwnChanges': true\n    };\n    return MutationSummary;\n})();\n\nmodule.exports = MutationSummary\n\n\n//# sourceURL=webpack:///./node_modules/mutation-summary/src/mutation-summary.js?");

/***/ }),

/***/ "./src/DomTreeSerializer.js":
/*!**********************************!*\
  !*** ./src/DomTreeSerializer.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar MutationSummary = __webpack_require__(/*! mutation-summary */ \"./node_modules/mutation-summary/src/mutation-summary.js\");\n\nfunction DomTreeSerializer(target, mirror) {\n    var _this = this;\n    this.target = target;\n    this.mirror = mirror;\n    this.nextId = 1;\n    this.knownNodes = new MutationSummary.NodeMap();\n    var rootId = this.serializeNode(target).id;\n    var children = [];\n    for (var child = target.firstChild; child; child = child.nextSibling) {\n        children.push(this.serializeNode(child, true));\n    }this.mirror.initialize(rootId, children);\n    var self = this;\n    this.mutationSummary = new MutationSummary({\n        rootNode: target,\n        callback: function callback(summaries) {\n            _this.applyChanged(summaries);\n        },\n        queries: [{ all: true }]\n    });\n}\n\nDomTreeSerializer.prototype.disconnect = function () {\n    if (this.mutationSummary) {\n        this.mutationSummary.disconnect();\n        this.mutationSummary = undefined;\n    }\n};\nDomTreeSerializer.prototype.rememberNode = function (node) {\n    var id = this.nextId++;\n    this.knownNodes.set(node, id);\n    return id;\n};\nDomTreeSerializer.prototype.forgetNode = function (node) {\n    this.knownNodes.delete(node);\n};\nDomTreeSerializer.prototype.serializeNode = function (node, recursive) {\n    if (node === null) return null;\n    var id = this.knownNodes.get(node);\n    if (id !== undefined) {\n        return { id: id };\n    }\n    var data = {\n        nodeType: node.nodeType,\n        id: this.rememberNode(node)\n    };\n    switch (data.nodeType) {\n        case Node.DOCUMENT_TYPE_NODE:\n            var docType = node;\n            data.name = docType.name;\n            data.publicId = docType.publicId;\n            data.systemId = docType.systemId;\n            break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n            data.textContent = node.textContent;\n            break;\n        case Node.ELEMENT_NODE:\n            var elm = node;\n            data.tagName = elm.tagName;\n            data.attributes = {};\n            for (var i = 0; i < elm.attributes.length; i++) {\n                var attr = elm.attributes[i];\n                data.attributes[attr.name] = attr.value;\n            }\n            if (recursive && elm.childNodes.length) {\n                data.childNodes = [];\n                for (var child = elm.firstChild; child; child = child.nextSibling) {\n                    data.childNodes.push(this.serializeNode(child, true));\n                }\n            }\n            break;\n    }\n    return data;\n};\nDomTreeSerializer.prototype.serializeAddedAndMoved = function (added, reparented, reordered) {\n    var _this = this;\n    var all = added.concat(reparented).concat(reordered);\n    var parentMap = new MutationSummary.NodeMap();\n    all.forEach(function (node) {\n        var parent = node.parentNode;\n        var children = parentMap.get(parent);\n        if (!children) {\n            children = new MutationSummary.NodeMap();\n            parentMap.set(parent, children);\n        }\n        children.set(node, true);\n    });\n    var moved = [];\n    parentMap.keys().forEach(function (parent) {\n        var children = parentMap.get(parent);\n        var keys = children.keys();\n        while (keys.length) {\n            var node = keys[0];\n            while (node.previousSibling && children.has(node.previousSibling)) {\n                node = node.previousSibling;\n            }while (node && children.has(node)) {\n                var data = _this.serializeNode(node);\n                data.previousSibling = _this.serializeNode(node.previousSibling);\n                data.parentNode = _this.serializeNode(node.parentNode);\n                moved.push(data);\n                children.delete(node);\n                node = node.nextSibling;\n            }\n            var keys = children.keys();\n        }\n    });\n    return moved;\n};\nDomTreeSerializer.prototype.serializeAttributeChanges = function (attributeChanged) {\n    var _this = this;\n    var map = new MutationSummary.NodeMap();\n    Object.keys(attributeChanged).forEach(function (attrName) {\n        attributeChanged[attrName].forEach(function (element) {\n            var record = map.get(element);\n            if (!record) {\n                record = _this.serializeNode(element);\n                record.attributes = {};\n                map.set(element, record);\n            }\n            record.attributes[attrName] = element.getAttribute(attrName);\n        });\n    });\n    return map.keys().map(function (node) {\n        return map.get(node);\n    });\n};\nDomTreeSerializer.prototype.applyChanged = function (summaries) {\n    var _this = this;\n    var summary = summaries[0];\n    var removed = summary.removed.map(function (node) {\n        return _this.serializeNode(node);\n    });\n    var moved = this.serializeAddedAndMoved(summary.added, summary.reparented, summary.reordered);\n    var attributes = this.serializeAttributeChanges(summary.attributeChanged);\n    var text = summary.characterDataChanged.map(function (node) {\n        var data = _this.serializeNode(node);\n        data.textContent = node.textContent;\n        return data;\n    });\n    this.mirror.applyChanged(removed, moved, attributes, text);\n    summary.removed.forEach(function (node) {\n        _this.forgetNode(node);\n    });\n};\n\nmodule.exports = DomTreeSerializer;\n\n//# sourceURL=webpack:///./src/DomTreeSerializer.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _DomTreeSerializer = __webpack_require__(/*! ./DomTreeSerializer */ \"./src/DomTreeSerializer.js\");\n\nvar _DomTreeSerializer2 = _interopRequireDefault(_DomTreeSerializer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getPathTo(element) {\n    if (element.id !== '') return 'id(\"' + element.id + '\")';\n    if (element === document.body) return element.tagName;\n\n    var ix = 0;\n    var siblings = element.parentNode.childNodes;\n    for (var i = 0; i < siblings.length; i++) {\n        var sibling = siblings[i];\n        if (sibling === element) return getPathTo(element.parentNode) + '/' + element.tagName + '[' + (ix + 1) + ']';\n        if (sibling.nodeType === 1 && sibling.tagName === element.tagName) ix++;\n    }\n}\n\nvar ElasticRecord = function sequenceIIFE() {\n    var timeoutForMouseMove;\n    var timeoutForScroll;\n    var useCache = true;\n    var dts;\n    var reset = true;\n\n    document.addEventListener('mousemove', function (_ref) {\n        var pageX = _ref.pageX,\n            pageY = _ref.pageY;\n\n        if (!timeoutForMouseMove) {\n            timeoutForMouseMove = setTimeout(function () {\n                clearTimeout(timeoutForMouseMove);\n                timeoutForMouseMove = null;\n            }, 300);\n            eRecord.sendEvent('MOUSE_MOVE', { pageX: pageX, pageY: pageY });\n        }\n    });\n\n    document.addEventListener('mousemove', function (_ref2) {\n        var pageX = _ref2.pageX,\n            pageY = _ref2.pageY;\n\n        if (!timeoutForMouseMove) {\n            timeoutForMouseMove = setTimeout(function () {\n                clearTimeout(timeoutForMouseMove);\n                timeoutForMouseMove = null;\n            }, 300);\n            eRecord.sendEvent('MOUSE_MOVE', { pageX: pageX, pageY: pageY });\n        }\n    });\n\n    document.addEventListener('keydown', function (event) {\n        if (event.target.localName === 'input') {\n            var xpath = getPathTo(event.target);\n            eRecord.sendEvent('INPUT_CHANGE', { xpath: xpath, value: event.target.value });\n        }\n    });\n\n    document.addEventListener('scroll', function (_ref3) {\n        var pageX = _ref3.pageX,\n            pageY = _ref3.pageY;\n\n        if (!timeoutForScroll) {\n            timeoutForScroll = setTimeout(function () {\n                clearTimeout(timeoutForScroll);\n                timeoutForScroll = null;\n            }, 300);\n            eRecord.sendEvent('SCROLL', { pageX: pageX, pageY: pageY });\n        }\n    });\n\n    document.addEventListener('click', function (_ref4) {\n        var pageX = _ref4.pageX,\n            pageY = _ref4.pageY;\n\n        eRecord.sendEvent('CLICK', { pageX: pageX, pageY: pageY });\n    });\n\n    return {\n        init: function init() {\n            var _this = this;\n\n            if (reset) {\n                localStorage.setItem('sessionData', JSON.stringify({\n                    events: [],\n                    start: Date.now()\n                }));\n            }\n            dts = new _DomTreeSerializer2.default(document, {\n                initialize: function initialize(rootId, children) {\n                    _this.sendEvent('DOM_INIT', { rootId: rootId, children: children });\n                },\n                applyChanged: function applyChanged(removed, addedOrMoved, attributes, text) {\n                    _this.sendEvent('DOM_CHANGE', { removed: removed, addedOrMoved: addedOrMoved, attributes: attributes, text: text });\n                }\n            });\n        },\n        sendEvent: function sendEvent(eventName, eventData) {\n            console.log('recorded event name: ' + eventName + ', details:', eventData);\n            var eventDataToSend = JSON.stringify(eventData);\n\n            if (useCache) {\n                var localStorageObject = {\n                    events: [],\n                    start: Date.now()\n                };\n\n                if (localStorage.getItem('sessionData')) {\n                    var tmpObj = JSON.parse(localStorage.getItem('sessionData'));\n                    if (tmpObj.events && Array.isArray(tmpObj.events)) {\n                        localStorageObject = tmpObj;\n                    }\n                }\n\n                localStorageObject.events.push({\n                    type: 'event',\n                    data: {\n                        name: eventName,\n                        data: eventDataToSend,\n                        ts: Date.now()\n                    }\n                });\n                localStorage.setItem('sessionData', JSON.stringify(localStorageObject));\n            } else {\n                var oReq = new XMLHttpRequest();\n                oReq.onload = function () {\n                    console.log('Inside the onload event');\n                };\n                oReq.onreadystatechange = function () {\n                    console.log('onreadystatechange');\n                };\n                oReq.open('GET', 'http://localhost:3000/event?name=' + eventName + '&data=' + eventDataToSend + '&ts=' + Date.now(), true);\n                oReq.send();\n            }\n        }\n    };\n};\n\nvar eRecord = new ElasticRecord();\neRecord.init();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });